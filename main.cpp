
#include "main.h"

static void thread1(void *);
static void thread2(void *);

void SystemClock_Config(void);






int main(void)
{
	HAL_Init(); 
	SystemClock_Config();
	Dac_1::init();
	Usart_2::init();
	Tim::init();
	Waves::init();
	//Tests::output_sine();
	xTaskCreate(thread1, "thread1", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
	xTaskCreate(thread2, "dummy_test", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
	vTaskStartScheduler();
	 /* We should never get here as control is now taken by the scheduler */
	for (;;);
}


extern "C" {
	void SysTick_Handler(void)
	{
		HAL_IncTick();
		osSystickHandler();
	}
}

void TIM2_IRQHandler_cpp(void) {
	float sample = Sample_buffer::get_next_sample().value;
	//TODO: Check optional
	Dac_1::set_value_rel((float) sample);
}


extern "C" {
	void TIM2_IRQHandler(void)
	{
		TIM2_IRQHandler_cpp();
		HAL_TIM_IRQHandler(&(Tim::htim2));
	}
}

#define NUM_VOICES 16

static void thread1(void *argument)
{
	(void) argument;
	
	//uint32_t test_sample_number {0}	;
	//float test_sample {0};
	//float test_sample_rel {0};
	//bool buffer_add_success {false};
	//
	
	Global_parameters global_parameters;
	//All voices will be initialised off
	Voice voice_array[NUM_VOICES];
	uint64_t sample_number {0};
	
	//global parameters. 
//have at task level
//pass to voice when note on
//how does run loop work?
// will be asyncronous
	
	

	//TODO: velocity is a byte?
	voice_array[0].turn_on(global_parameters, 1000, 255);





	
	
	while (1) {
		//this will be running all the time, filling in the gaps to fill the queue
		//how about adding voice
		//use rtos queue
		
		//if slot available
		//calculate sample
		//add new sample
		//may not need float optional
		//check for new message (this could be at start
		
		

	
		
		
		//at the m
		uint32_t voice_index {0};
		float total {0};
		for (voice_index = 0 ; voice_index < NUM_VOICES; voice_index++) {
			total += voice_array[voice_index].get_next_sample(
				
			
			

		
			
		}
		
		
		
		
		//test_sample = Waves::get_sample_with_sample_number_sine(test_sample_number);
		//test_sample_rel = test_sample * (float) 0.5 + (float) 0.5; 	
		//buffer_add_success = Sample_buffer::add_sample(test_sample_rel);
		//if (!buffer_add_success)
			//taskYIELD()
		//else
			//test_sample_number++;
		//if (test_sample_number == NUM_SAMPLES_PER_WAVE)
			//test_sample_number = 0;
	}
}

static void thread2(void *argument)
{
	(void) argument;
	while (1) ;
}

//Mainly autogenerated code
//180MHz clock
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct {}	;
	RCC_ClkInitTypeDef RCC_ClkInitStruct {}	;

	/** Configure the main internal regulator output voltage 
	*/
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
	/** Initializes the CPU, AHB and APB busses clocks 
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = 16;
	//Tuned for my microcontroller
  RCC_OscInitStruct.PLL.PLLN = 374;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 2;
	RCC_OscInitStruct.PLL.PLLR = 2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		while (1) ;
	}
	/** Activate the Over-Drive mode 
	*/
	if (HAL_PWREx_EnableOverDrive() != HAL_OK)
	{
		while (1) ;
	}
	/** Initializes the CPU, AHB and APB busses clocks 
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
	                            | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
	{
		while (1) ;
	}
}

